### 펌웨어 (Firmware)

- 하드웨어를 제어하거나 하드웨어에 특정 기능을 수행하게 하기 위해 작성된 소프트웨어 코드.
- 비휘발성 메모리(ROM, Flash 등)에 저장되어 실행되는 프로그램. 왜?
    - 전원이 꺼져도 데이터를 유지해야하기 때문.
    - 고속 부팅 및 안정적인 실행이 필요하기 때문.
- 하드웨어와 소프트웨어의 중간에 존재하는 개념.
- 하드웨어의 동작을 정의하는 역할을 하며 하드웨어 변경 없이도 기능 수정이나 업데이트가 가능함.

### 펌웨어와 RTOS의 차이

|  | 펌웨어 (Bare-metal) | RTOS (Real-Time OS) |
| --- | --- | --- |
| 우선순위 | 없음 | 있음 (Task 별 우선순위 지정) |
| 멀티태스킹 | 단일 루프 | 멀티태스크, 스케줄러 기반 |
| 실시간성 | 중간 (타이머/인터럽트 기반) | 높음 (정밀, 우선순위 기반) |
| 자원관리 | 직접 구현 | 내장 자원관리 기능 있음 |
| 디버깅/유지보수 | 비교적 어려움 | 상대적으로 쉬움 |

### 펌웨어로 구현하기 어려운 기능

- 복잡한 사용자 인터페이스 처리
- 고급 운영체제 수준의 자원 관리 (멀티태스킹, 메모리 보호 등)
- 대용량 파일 처리 및 네트워크 다중 연결

### 펌웨어와 App의 차이

- 펌웨어: 하드웨어를 제어하거나 동작시키기 위한 코드
    - 스마트폰의 터치 인식 기능 - 펌웨어
- App: 사용자가 직접 실행하거나 조작하는 소프트웨어
    - 카카오톡 - App

### 펌웨어 업데이트 방법

- 펌웨어 업데이트는 전원 중단 방지 및 안정성 확보가 매우 중요함.
- 업데이트 실패 시 장치가 부팅되지 않을 수 있음.

<aside>

- JTAG/SWD 등 디버거 이용
    - 개발 중 가장 일반적.
    - 외부 디버거로 MCU 직접 접근해 업데이트.
- UART, USB, SPI 등 시리얼 통신
    - 부트로더를 통해 펌웨어 이미지 전송.
    - 일반적으로 XMODEM, DFU 프로토콜 사용.
- 무선 OTA (Over-the-Air)
    - Wi-Fi, BLE 등 무선통신으로 원격 업데이트.
    - IoT 장치에서 흔히 사용됨.
- SD 카드/외부 저장소 이용
    - 펌웨어 파일을 저장 후, 부트로더가 읽어 적용.
</aside>

---

### RTOS (Real-Time Operating System)

- 실시간 처리 능력을 갖춘 운영체제.
- 제한된 시간 내에 정해진 작업을 수행해야 하는 임베디드 시스템에서 사용됨.
- 일정한 주기나 이벤트에 따라 즉각적인 반응을 요구하는 시스템에서 사용됨.
    - ex. 자동차 제어, 로봇 제어 등
- Real-time의 의미
    - 정해진 시간 내에 응답이나 처리를 보장할 수 있는 능력.
    - '빠름'이 아니라 '정해진 시간에 반드시' 수행됨이 핵심!

### RTOS 디버깅 및 문제해결 방안

- Deadlock (교착 상태)
    - 둘 이상의 태스크(Task) 또는 스레드(Thread)가 서로 자원을 점유한 채, 상대방의 자원을 기다리면서 영원히 실행되지 않는 상태.
    - 뮤텍스(mutex)나 세마포어(semaphore)를 여러 개 사용하는 경우, 순서가 꼬이면 발생.
    - 자원 획득 순서를 정해 두고 일관성 있게 사용.
    - 타임아웃 기능을 이용하여 자원 대기 시간을 제한.
    - 데드락 검출 알고리즘 또는 watchdog timer 활용.
- 타이밍 맞추기
    - 실시간성 요구로 인해 태스크들이 정확한 주기나 우선순위로 실행되지 않으면 오작동 발생 가능.
    - RTOS의 타이머 서비스, 딜레이 API(vTaskDelay, vTaskDelayUntil) 활용.
    - 태스크 우선순위를 적절히 조정.
    - 필요한 경우 하드웨어 타이머 활용 (e.g., PWM, RTC).
    - 태스크 간 시간 동기화를 위해 semaphore나 event group 사용.
- 뮤텍스(Mutex)
    - 여러 태스크가 공유 자원에 동시에 접근하지 못하도록 막는 동기화 기법.
    - 소유한 태스크만이 해제 가능.
    - 우선순위 역전(Priority Inversion) 문제 발생 가능.
    - 이를 해결하기 위해 RTOS에서는 Priority Inheritance Protocol 제공.

### 우선순위 (Priority)

- 프로그램 간의 중요도에 따라 실행 순서를 정함.
    - 센서 데이터 - 즉각 처리해야 하므로 우선 순위가 높음.
    - 로그 저장 - 늦어도 무방하므로 우선 순위가 낮음.
- 우선순위 역전 현상 (Priority Inversion)
    - 낮은 우선순위 태스크가 공유 자원을 점유하고 있고,
    - 높은 우선순위 태스크는 이를 기다리느라 실행되지 못하는 상황.
    - 낮은 우선순위 태스크가 임시로 높은 우선순위를 부여받아 실행하여 해결.

### 교착상태 (DeadLock)

- 둘 이상의 태스크가 서로가 점유한 자원을 기다리며 무한히 대기하는 상태
- deadlock 발생 조건
    - 상호 배제(Mutual Exclusion)
    - 점유와 대기(Hold and Wait)
    - 비선점(No Preemption)
    - 순환 대기(Circular Wait)
- deadlock 해결 방법
    - 자원 순서 고정
    - 타임아웃 적용
    - 예방: Deadlock 발생 조건 중 하나 이상을 제거
    - 회피: 은행원 알고리즘 등 사용
    - 가장 쉬운 해결 방법: 시스템 리셋 (단, 실시간 시스템에서는 부적절)

### 스케쥴러/시스템프로그래밍 vs 일반 프로그램

|  | 스케쥴러/시스템프로그래밍 | 일반 프로그램 |
| --- | --- | --- |
| 목적 | 자원 및 태스크 관리 | 기능 수행 |
| 예시 | RTOS 커널, 스케줄러 | 사용자 앱, 알고리즘 |
- 스케쥴러의 용도
    - 태스크 실행 순서 관리
    - 우선순위에 따른 제어
    - 실시간 요구 충족

### 칩셋에 따른 소프트웨어 선택

- 8비트 칩셋에 RTOS 탑재가 가능한가?
    - AVR(예: ATmega 시리즈)와 같은 8-bit MCU에도 경량 RTOS 탑재 가능.
    - 대표적으로 FreeRTOS, TinyOS, ChibiOS 등의 초경량 RTOS 사용.
    - RAM과 Flash 메모리가 매우 제한되어 있어 RTOS의 기능도 매우 제한됨.
    - 일반적으로는 RTOS보다 bare-metal(루프 기반) 방식 선호.
- RTOS 실행의 최소 조건
    - RAM: 약 1KB 이상 (실제 태스크 수, 스택 크기에 따라 달라짐)
    - Flash: 약 4~10KB 이상
    - 타이머 인터럽트 지원: 시스템 tick 생성을 위해 필요
    - 스택과 힙 메모리 구분
    - 컨텍스트 스위칭을 위한 CPU 레지스터 접근 가능
- 32 / 64비트 칩셋에서도 펌웨어 사용이 가능한가?
    - 펌웨어는 하드웨어 제어용 소프트웨어이므로 CPU 비트수와는 무관하게 존재할 수 있음.
    - 32/64비트 시스템은 일반적으로 더 많은 기능 제공 → Linux, RTOS 등 다양한 운영체제 선택 가능.
    - 펌웨어는 여전히 부트로더, 디바이스 초기화, 실시간 제어 등에서 활용됨.

### 펌웨어에서 멀티태스킹이 되지 않는 이유

- 일반적인 펌웨어는 bare-metal 방식으로 무한 루프(one main loop)에서 순차적으로 동작합니다.
- 스케줄러나 태스크 관리 기능이 없기 때문에 멀티태스킹 불가능.
- 모든 작업은 직렬 처리되며 인터럽트를 제외하면 동시성 없음.

### RTOS에서 응용 프로그램과 시스템 프로그램 간 경계가 명확하지 않은 이유

- RTOS는 경량화를 위해 운영체제와 사용자 코드가 같은 메모리 공간에 존재.
- 커널, 드라이버, 태스크 코드가 분리되지 않고 하나로 동작.
- 메모리 보호 기능이 없는 경우가 많아 구조적으로 계층 구분이 어려움.

### 펌웨어나 RTOS보다 임베디드 리눅스가 점점 더 많이 쓰이게 된 이유

- 고성능 칩셋의 등장으로 리눅스 구동이 가능해짐.
- 파일 시스템, 네트워크, 보안, 멀티태스킹, 다양한 드라이버 지원 등 풍부한 기능.
- 개발 편의성 향상 (e.g., Python, shell, 패키지 시스템 사용 가능).
- IoT, AI, 네트워크 장비 등 복잡한 시스템 요구를 충족시킴.

### 펌웨어나 임베디드 리눅스에서 구현하기 어려운 RTOS만의 특징

- 정밀한 실시간성: 수 µs~ms 단위의 정확한 태스크 실행.
- Deterministic Scheduling: 항상 예측 가능한 응답 시간.
- 경량 구조: 수 KB 수준의 리소스로 동작.
- 하드 실시간 제어: 모터 제어나 센서 응답 등 즉각적인 처리가 필요한 환경에 최적.