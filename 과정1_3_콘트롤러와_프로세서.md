# 과정 1 | 문제 3

### 모빌리티 3팀 은대영

---

## 수행 목표
<br>


### 논리회로란 무엇인가

**논리회로(logic circuit)**: 전기적 신호(보통 0과 1, On/Off)를 입력받아 논리적 연산(AND, OR, NOT 등)을 수행하고 그 결과를 출력하는 전자회로
컴퓨터, 스마트폰, 가전제품 등 거의 모든 전자기기의 핵심을 이루는 기본적인 부품
<br>


### 논리회로의 기본 종류
#### NOT 회로
- 입력이 1이면 출력이 0, 입력이 0이면 출력이 1이 되는 회로

#### AND 회로
- 두개 이상의 입력이 모두 1일때만 출력이 1이 되는 회로

#### OR 회로
- 두개 이상의 입력 중에서 하나만 1이어도 출력이 1이 되는 회로

#### NAND 회로
- AND 회로의 출력에 NOT을 적용한 회로
즉, 모든 입력이 1일때만 출력이 0, 그 외는 1

#### NOR 회로
- OR회로의 출력에 NOT을 적용한 회로
모든 입력이 0일때만 출력이 1, 그 외에는 0

#### XOR 회로 (베타적 논리합)
- 두 입력이 서로 다를때만 출력이 1이 되는 회로

#### XNOR 회로 (베타적 논리곱)
- 두 입력이 같을때만 출력이 1이 됨, XOR의 반대
<br>


### 내가 이해한 논리회로란?
- 논리회로는 전기 신호 0과 1을 이용해서 논리적인 판단을 할 수 있도록 만들어진 회로임. 스위치가 모두 켜져야 불이 켜지거나, 하나만 켜도 불이 켜지는 것처럼 논리회로는 입력 조건에 따라 다양한 결과를 만들어 낼 수 있음.

- 가장 단순한 논리회로는 스위치 하나로 On/Off를 제어하는 것이고, 이 원리를 확장하여 여러 개의 입력을 조합하여 더 복잡한 조건으로 연산과 제어가 가능하기 때문에, 논리회로를 이해하는 것은 전자공학과 컴퓨터의 원리 등을 이해하는데 매우 중요할 것으로 사료됨.
<br>


### 마이크로컨트롤러(MCU)와 마이크로프로세서(MPU)의 차이
#### 구성
- MCU: CPU, 메모리, I/O 모든 기능이 단일 칩에 내장
- MPU: CPU만 내장, 메모리와 I/O는 외부 연결 필요

#### 용도
- MCU: 임베디드 시스템, 특정 제어 목적, 임베디드 시스템, 소형화, 대량 생산 적합
- MPU: 범용 컴퓨팅, 복잡한 연산 및 멀티태스킹, PC, 서버, 스마트폰 등등

#### 전력 소비
- MCU: 저전력, 저비용, 소형화
- MPU: 고전력, 고비용, 추가 부품 필요요

#### 성능
- MCU: 낮음~중간, 실시간 제어에 최적화
- MPU: 높음, 복잡한 연산과 멀티태스킹

#### 크기/비용
- MCU: 작고 저렴, 단일 칩 설계 가능
- MPU: 크고 비쌈, 추가 부품 필요

#### 구조
- MCU: 하버드 구조(프로그램과 데이터 메모리 분리)
- MPU: 폰 노이만 구조(프로그램과 데이터 메모리 통합)

#### OS
- MCU: 필요 없음(펌웨어만으로 동작 가능)
- MPU: 운영체제 필요(윈도우, 리눅스 등)

#### 예시
- MCU: 세탁기, 자동차, IoT 기기
- MPU: PC, 서버, 스마트폰
<br>


### 비슷해 보이지만 차이가 나는 이유?
- 두 제품 모두 컴퓨터의 두뇌 역할을 하는 전자기기의 핵심 부품이지만, 설계 목적과 사용 환경이 다름
- MCU는 모든 기능이 한 칩에 내장되어 저전력, 저비용, 특정 제어에 최적화
- MPU는 고성능 연산에 집중된 범용 CPU로 외부 부품과 결합해 복잡한 시스템 구성
<br>


### 자동차 MCU에 마이크로 컨트롤러가 주로 사용되는 이유
- 실시간 제어: 엔진 제어, 브레이크 시스템 등 시간에 민감한 작업에 적합
- 저전력, 고신뢰성: 단순한 아키텍처로 적은 전력 소모, 극한 환경에서 안정적
- 통합성: 센서, 액추에이터 제어를 위한 ADC, PWM 등의 주변장치 내장
<br>


### 피지컬 어드레스 vs 버추얼 어드레스
- 피지컬 어드레스: 실제 메모리 하드웨어에 직접 접근하기 위한 주소. MCU에서는 일반적으로 피지컬 어드레스만 사용됨
- 버추얼 어드레스: MPU에서 운영체제가 제공하는 가상의 메모리 주소 체계. MMU(Memory Management Unit)가 가상 주소를 물리 주소로 변환하여 메모리 보호와 멀티태스킹 지원
<br>


### Super 영역역(커널 모드) vs User 영역(사용자 모드)
- 권한 구분 이유
    - 보안 강화: 사용자 프로그램이 직접 하드웨어나 중요한 시스템에 접근하는 행위 차단
    - 시스템 안정성: 잘못된 명령어 실행으로 인한 전체 시스템 충돌 방지 (본인도 전에 OS 날려먹어본 경험이 있음)
    - MPU는 일반적으로 두 모드를 지원하지만, MCU는 대부분 단일 권한 모드(베어메탈)로 동작함
<br>


### MMU(Memory Management Unit)
- 가상 메모리 관리, 주소 변환, 메모리 보호를 담당
- 복잡한 운영체제(Linux, Windows)에서 필수적이며, MCU에는 일반적으로 없음
<br>


### 아두이노에 쓰이는 칩셋
- 아두이노에 사용되는 칩셋은 ATmega328P와 같은 MCU
- 아두이노는 MCU를 기반으로 개발된 보드이며, 8비트나 32비트 기반의 MCU를 사용함
- MCU는 CPU, 메모리, 입출력 포트를 하나의 칩에 통합한 소형 컴퓨터로 독립적 동작 가능
<br>


### 8비트 칩셋은 MPU인가?
- 8비트 칩셋이 MCU인지 MPU인지는 칩의 구조에 따라 다름
- 8비트라는 비트 수는 단순히 레지스터와 데이터 버스의 크기인 8비트 처리 단위를 의미할 뿐, 이 칩이 마이크로컨트롤러인지 마이크로프로세서인지는 내부에 무엇이 포함되어 있는지에 따라 결정됨
- ##### 따라서, 아두이노에 쓰이는 8비트 ATmega328P는 MCU임
<br>


### 32/64, 8/16비트 칩셋 차이
#### 비트 수의 의미
- 비트 수(8, 16, 32, 64)는 CPU가 한번에 처리할 수 있는 데이터의 크기(레지스터, 데이터 버스 폭)를 나타냄
- 예를 들어, 8비트 CPU는 한번에 8비트(1바이트) 데이터를, 32비트 CPU는 32비트(4바이트) 데이터를 처리 가능

#### 주요 차이점
- 32/64비트 칩셋은 한번에 더 큰 수를 처리하고, 더 많은 메모리에 접근하며, 복잡한 연산 및 멀티태스킹에 유리
- 8/16비트 칩셋은 하드웨어 자원이 제한적이지만 저전력, 저비용, 단순 제어 등에 적합

#### 64비트 프로세서는 MCU인가?
- 설계 목적: 64비트 프로세서는 고성능 연산(서버, AI, PC)에 최적화되어 있으며, 외부 메모리와 주변장치를 필요로 함
- MCU는 단일 칩에 메모리와 주변 장치를 통합하지만, 64비트 프로세서는 범용 연산에 집중중
<br>


#### 펌웨어 호환성: 32비트 vs 64비트
##### 펌웨어
- 32비트: C/어셈블리로 작성된 펌웨어 직접 실행 가능
- 64비트: 호환성 없음

##### 포트링
- 32비트: 소스 코드 재컴파일 필요
- 64비트: 아키텍처 전환 시 대규모 수정 필요

##### 결론
- 32비트 펌웨어: 64비트 MPU에서 에뮬레이션 가능하나, 성능 손실 발생
- 64비트 전용 펌웨어: 64비트와 32비트는 명령어 세트가 완전히 다름
- MMU와 권한 분리는 MPU의 핵심 보안 매커니즘이며, 64비트 아키텍처는 범용 컴퓨팅에 집중
- 펌웨어 이식성은 비트 수보다 아키텍처와 ISA 호환성에 좌우됨
<br>


### MCU와 MPU에 사용되는 프로세서
#### 마이크로컨트롤러(MCU)
- SW: 펌웨어, 임베디드 APK, RTOS 등
- 개발환경: Arduino IDE, Atmel Studio 등
- 언어: C, C++, 어셈블리, MicroPython 등
- OS: 대부분의 8/16비트 MCU는 Non OS
- 일부 32비트에서 RTOS 사용 가능
<br>


#### 마이크로프로세서(MPU)
- SW: 범용 운용체제(윈도우, 리눅스, 안드 등), 데스크탑/모바일 APK, 서버 SW 등
- 개발환경: VS Studio, Eclipse, GCC, VS code 등
- 언어: C, C++, Python, Java 등
<br>


#### 8비트 칩셋 SW 
- 일반적으로 OS를 사용하지 않고 펌웨어/임베디드 APK를 직접 작성하여 구동
- 메모리와 연산 능력이 매우 제한적이나 일부 초경량 RTOS가 제한적으로 사용가능
<br>


#### 16/32비트 칩셋 SW
- 16비트: 대부분 OS 없이 동작, 펌웨어/임베디드 APK 중심
- 32비트: RTOS 사용 가능, 일부 고성능 MCU에서 리눅스 등의 범용 OS 구동 가능
<br>


#### 비트 수에 따른 SW 차이
- 8비트: 매우 제한된 메모리와 연산 능력 -> OS 없이 펌웨어 직접 작성
- 간단한 제어, 센서 데이터 처리 등
- 16/32비트: 더 많은 메모리와 연산 능력 -> RTOS, 복잡한 임베디드 애플리케이션, 일부 범용 OS 구동 가능
- 고급 제어, 통신, 데이터 처리 등 복잡한 작업 수행 가능
<br>