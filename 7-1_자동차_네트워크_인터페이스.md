### 자동차 내 네트워크 인터페이스의 기본 개념

- 네트워크 인터페이스
    - 차량 내부에서 ECU (Electronic Control Unit) 간에 데이터를 송수신할 수 있도록 해주는 통신 경로와 프로토콜.
    - 센서, 액추에이터, 제어 장치 등이 서로 정보를 주고받아 차량 기능을 제어하고 동기화하도록 함.
- 왜 필요한가?
    - 제어 분산화: 차량의 다양한 기능(브레이크, 엔진, 조향 등)이 개별 ECU로 분산되어 있어 이들 간의 통신이 필수적
    - 복잡한 기능 통합: ADAS(첨단 운전자 지원 시스템), 자율주행 등 복잡한 시스템 통합에 있어 빠르고 정확한 통신이 필요
    - 안전성과 신뢰성 확보: 실시간 제어가 필요한 시스템에서 신뢰성 있는 통신은 생명과 직결됨

### 주요 자동차 네트워크 인터페이스의 특징과 용도

- CAN (Controller Area Network)
    - 다중 마스터, 오류 검출, 최대 1Mbps
    - 엔진, 변속기, ABS 등
- LIN (Local Interconnect Network)
    - 저속, 단일 마스터-슬레이브 구조, 저비용
    - 창문, 시트, 미러 등 보조 시스템
- FlexRay
    - 고속, 이중화, 정시성 보장
    - 브레이크, 서스펜션, 자율주행 시스템
- Ethernet (자동차용)
    - 고속(최대 1Gbps 이상), 대용량 데이터
    - 인포테인먼트, ADAS, 카메라

### 임베디드 리눅스 시스템에서의 네트워크 인터페이스 구현 방법

- 구현 요소
    - 하드웨어 인터페이스: CAN 컨트롤러 (MCP2515 등), USB2CAN 장치 등
    - 커널 드라이버: SocketCAN 드라이버 또는 특수 디바이스 드라이버
    - 유틸리티/라이브러리: can-utils 등 사용자 공간 도구
    - 애플리케이션: 사용자 정의 프로그램(C, Python 등)으로 통신 제어 및 데이터 처리

- 커널 지원: SocketCAN
    - 리눅스 커널이 제공하는 CAN 프로토콜 지원 프레임워크
    - 기존 TCP/UDP 소켓과 유사한 방식으로 CAN 통신을 사용할 수 있음
    - SocketCAN 구성 요소
        - vcan: 가상 CAN 인터페이스 (테스트용)
        - can, can_raw: 실제 CAN 인터페이스
        - can-utils: 통신 테스트를 위한 명령어 도구 모음

- 개발환경 세팅
    1. 커널 모듈/드라이버 준비
        - 리눅스 커널에서 CONFIG_CAN, CONFIG_CAN_RAW, CONFIG_CAN_VCAN, CONFIG_CAN_DEV 등의 모듈 활성화 필요
        - 대부분의 배포판에서는 이미 빌드되어 있음
        
        ```bash
        # 모듈 확인
        lsmod | grep can
        ```
        
    2. 가상 CAN 인터페이스 설정 (개발/테스트 용도)
        
        ```bash
        sudo modprobe vcan
        sudo ip link add dev vcan0 type vcan
        sudo ip link set up vcan0
        ```
        
    3. 실제 CAN 인터페이스 설정 (예: USB2CAN)
        
        ```bash
        sudo ip link set can0 up type can bitrate 500000
        ```
        
    4. can-utils 설치 및 통신 테스트
        
        ```bash
        sudo apt install can-utils
        
        # 송신
        cansend can0 123#DEADBEEF
        
        # 수신
        candump can0
        ```
        

- 사용자 애플리케이션 개발 - C언어 예시 (SocketCAN 사용)
    
    ```c
    #include <linux/can.h>        // CAN 프레임 구조체 정의 (struct can_frame 등)
    #include <linux/can/raw.h>    // RAW 소켓용 CAN 정의 (CAN_RAW 등)
    #include <sys/socket.h>       // socket(), bind() 등 소켓 API
    #include <net/if.h>           // ifreq 구조체, 인터페이스 이름 설정용
    #include <string.h>           // strcpy(), memset() 등 문자열 처리
    #include <unistd.h>           // close() 함수
    
    int main() {
        int sock;                      // 소켓 디스크립터 변수
        struct sockaddr_can addr;     // 소켓 주소 구조체 (CAN 전용)
        struct ifreq ifr;             // 인터페이스 요청용 구조체 (예: can0)
        struct can_frame frame;       // 송신할 CAN 프레임 구조체
    
        // PF_CAN: 프로토콜 패밀리 CAN, SOCK_RAW: RAW 소켓, CAN_RAW: RAW 모드로 CAN 사용
        sock = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    
        // 사용할 CAN 인터페이스 이름을 ifr 구조체에 복사 (예: "can0")
        strcpy(ifr.ifr_name, "can0");
    
        // 인터페이스 이름을 통해 해당 인터페이스의 index 값을 가져옴
        ioctl(sock, SIOCGIFINDEX, &ifr);
    
        // 주소 구조체 설정: 주소 패밀리는 AF_CAN, 인터페이스 인덱스 설정
        addr.can_family = AF_CAN;
        addr.can_ifindex = ifr.ifr_ifindex;
    
        // 소켓을 can0 인터페이스에 바인딩
        bind(sock, (struct sockaddr *)&addr, sizeof(addr));
    
        // 송신할 CAN 프레임 구성
        frame.can_id = 0x123;     // CAN 식별자 (11비트 or 29비트 ID)
        frame.can_dlc = 2;        // 데이터 길이 (0 ~ 8 바이트)
        frame.data[0] = 0xAB;     // 첫 번째 데이터 바이트
        frame.data[1] = 0xCD;     // 두 번째 데이터 바이트
    
        // 프레임을 소켓을 통해 송신
        write(sock, &frame, sizeof(struct can_frame));
    
        // 소켓 종료
        close(sock);
    
        return 0;
    }
    ```
    

### 리눅스 커널에서 네트워크 인터페이스를 구현하는 방법

- 네트워크 장치 드라이버 작성
    - 네트워크 장치 등록
        - 네트워크 인터페이스를 등록하여, 커널에서 해당 장치를 활성화할 수 있도록 한다.
        - register_netdev() 함수는 네트워크 장치를 등록하는 함수이다.
    - 하드웨어 초기화
        - 네트워크 장치가 커널에 등록되면 하드웨어를 초기화하고 데이터를 송수신하는 함수들을 정의해야 한다.
    - 송수신 함수
        - 데이터를 보내고(receive), 받고(transmit) 하는 함수가 필요하다.
        - ndo_start_xmit() 함수는 네트워크 장치에서 송신 작업을 처리하며, ndo_open() 및 ndo_stop()은 네트워크 장치의 시작과 종료를 담당한다.
    - 인터럽트 처리
        - 하드웨어가 데이터를 수신했을 때 인터럽트를 발생시키고, 이를 처리하는 코드가 필요하다.
    - 네트워크 통계
        - 네트워크 장치에서 발생하는 오류, 패킷 전송 및 수신 통계 등을 추적하는 코드도 필요하다.

- 네트워크 인터페이스 드라이버의 구조
    - 주요 함수 및 구조체
        - net_device: 리눅스 커널에서 네트워크 인터페이스를 정의하는 구조체
        - ndo_start_xmit(): 데이터를 네트워크 장치로 전송하는 함수
        - ndo_open(), ndo_stop(): 네트워크 장치의 시작과 종료를 처리하는 함수
        - register_netdev(): 네트워크 장치를 리눅스 커널에 등록하는 함수
    - 예시코드
    
    ```c
    #include <linux/module.h>          // 리눅스 모듈 관련 함수 및 매크로
    #include <linux/kernel.h>          // printk() 등의 커널 로그 출력 함수
    #include <linux/netdevice.h>       // 네트워크 장치 관련 함수 및 구조체
    
    static struct net_device *dev;    // 네트워크 장치 구조체 포인터 선언
    
    // 네트워크 장치가 열릴 때 호출되는 함수 (open)
    static int my_open(struct net_device *dev)
    {
        printk(KERN_INFO "My Network Device Opened\n");  // 네트워크 장치가 열렸다는 메시지 출력
        return 0;  // 0을 반환하여 성공을 알림
    }
    
    // 네트워크 장치가 종료될 때 호출되는 함수 (stop)
    static int my_stop(struct net_device *dev)
    {
        printk(KERN_INFO "My Network Device Stopped\n");  // 네트워크 장치가 중지되었다는 메시지 출력
        return 0;  // 0을 반환하여 성공을 알림
    }
    
    // 네트워크 장치로 데이터를 전송하는 함수 (송신 함수)
    static netdev_tx_t my_xmit(struct sk_buff *skb, struct net_device *dev)
    {
        printk(KERN_INFO "Transmitting packet\n");  // 패킷 송신 시작 로그 출력
        dev_kfree_skb(skb);  // 송신된 패킷을 메모리에서 해제 (실제 송신은 구현되지 않음)
        return NETDEV_TX_OK;  // 송신 성공을 알림
    }
    
    // 네트워크 장치의 동작을 정의하는 구조체
    // 각 네트워크 장치의 함수 포인터를 설정 (open, stop, xmit 등)
    static struct net_device_ops netdev_ops = {
        .ndo_open = my_open,            // 장치가 열릴 때 호출될 함수
        .ndo_stop = my_stop,            // 장치가 중지될 때 호출될 함수
        .ndo_start_xmit = my_xmit,      // 패킷을 송신할 때 호출될 함수
    };
    
    // 네트워크 장치 초기화 함수
    // 장치가 초기화될 때 호출되어, 장치의 설정을 마친 후 사용할 준비를 한다.
    static void my_setup(struct net_device *dev)
    {
        dev->netdev_ops = &netdev_ops;  // 장치의 네트워크 동작을 정의한 netdev_ops 구조체를 연결
    }
    
    // 커널 모듈 초기화 함수 (__init 함수)
    // 모듈이 로드될 때 호출되어, 네트워크 장치를 등록한다.
    static int __init my_init(void)
    {
        // 네트워크 장치 구조체를 할당 (0개의 multicast 주소, 장치 이름은 "myeth%d" 형식)
        dev = alloc_netdev(0, "myeth%d", NET_NAME_UNKNOWN, my_setup);
    
        // 네트워크 장치를 커널에 등록
        if (register_netdev(dev)) {
            printk(KERN_ALERT "Registering the network device failed\n");  // 등록 실패 시 경고 메시지 출력
            return -1;  // 실패 시 -1 반환
        }
    
        printk(KERN_INFO "Network device registered\n");  // 등록 성공 시 정보 메시지 출력
        return 0;  // 성공적으로 초기화되었음을 알림
    }
    
    // 커널 모듈 종료 함수 (__exit 함수)
    // 모듈이 언로드될 때 호출되어, 네트워크 장치를 해제한다.
    static void __exit my_exit(void)
    {
        unregister_netdev(dev);  // 네트워크 장치를 커널에서 해제
        printk(KERN_INFO "Network device unregistered\n");  // 해제된 후 정보 메시지 출력
    }
    
    // 모듈의 초기화 함수와 종료 함수 등록
    module_init(my_init);  // 모듈 로드 시 호출될 함수
    module_exit(my_exit);  // 모듈 언로드 시 호출될 함수
    
    MODULE_LICENSE("GPL");  // 모듈 라이센스 정보 (GPL 라이센스)
    ```
    

- 네트워크 장치 드라이버의 테스트 및 사용
    - 모듈 컴파일 및 설치
        - 위의 코드가 포함된 커널 모듈을 **컴파일**하고 **로딩**하여 실제 하드웨어에 연결된 네트워크 인터페이스 장치가 동작하는지 테스트한다.
    - ifconfig 및 ip 명령어로 테스트
        - ifconfig 또는 ip link 명령어로 새로운 네트워크 인터페이스가 커널에 등록되어 있는지 확인한다.
    - 패킷 송수신 확인
        - ping, iperf, netcat 등의 툴을 사용하여 네트워크 장치가 정상적으로 데이터를 송수신하는지 테스트한다.

- 네트워크 인터페이스에 대한 고급 기능
    - QoS(서비스 품질): 패킷 우선순위와 처리 방식 설정
    - 네트워크 가상화: 하나의 물리적 인터페이스에서 여러 가상 인터페이스를 설정 (예: veth 인터페이스)
    - 패킷 필터링: iptables와 결합하여 네트워크 장치의 패킷을 필터링하거나 처리

- 네트워크 인터페이스 통합 및 디버깅
    - 리눅스 네트워크 드라이버는 커널 로그를 통해 디버깅할 수 있으며, dmesg 명령어를 사용하여 로그를 확인한다.
    - ethtool 명령어를 통해 네트워크 장치의 상태를 검사하고 설정을 조정할 수 있다.

### SocketCAN에 대한 내용

- 리눅스 커널에서 CAN(Controller Area Network) 통신을 처리하기 위한 인터페이스이다.
- 소켓 API를 사용하여 CAN 네트워크와 통신할 수 있게 해준다.
- 일반적으로 CAN 버스를 사용하는 장치와 통신하기 위해 리눅스 환경에서 많이 사용된다.
- SocketCAN은 리눅스의 네트워크 소켓 모델을 기반으로 하여 기존의 네트워크 통신 방식과 유사하게 CAN 메시지를 송수신할 수 있도록 도와준다.

- 소켓 기반 인터페이스:
    - 일반적인 네트워크 소켓처럼 socket(), bind(), read(), write() 등의 시스템 콜을 사용할 수 있다.
    - CAN 장치와 통신하는 방식은 네트워크 인터페이스 카드(NIC)와의 통신처럼 간단한 소켓 호출로 이루어진다.
- CAN 프레임을 다룸:
    - CAN 프레임을 송수신할 수 있으며, 이를 통해 차량의 ECU와 데이터를 주고받을 수 있다.
    - 각 CAN 메시지는 고유의 CAN ID와 데이터 길이, 데이터 값 등을 포함한다.
- 표준 소켓 API 사용:
    - 기존의 소켓 API를 그대로 사용할 수 있기 때문에, 네트워크 프로그래밍 경험이 있는 개발자는 쉽게 사용할 수 있다.
    - PF_CAN 프로토콜과 SOCK_RAW 타입을 이용하여 CAN 소켓을 생성한다.
- 다양한 CAN 장치 지원:
    - 리눅스에서는 여러 가지 종류의 CAN 하드웨어 인터페이스를 지원하며, USB-to-CAN, PCI-to-CAN 장치 등을 통해 다양한 하드웨어와 연결할 수 있다.
    - 소프트웨어로 가상 CAN 인터페이스도 제공하여 실제 하드웨어 없이도 테스트할 수 있다.
- CAN 필터링 기능:
    - CAN 통신에서는 필터링 기능을 통해 수신할 메시지를 제한할 수 있습니다.
    - 특정 CAN ID에 해당하는 메시지만 수신하거나, 특정 범위의 ID를 수신할 수 있도록 필터를 설정할 수 있다.

- CAN 소켓 생성 및 송신 예시

```c
#include <linux/can.h>
#include <linux/can/raw.h>
#include <sys/socket.h>
#include <net/if.h>
#include <string.h>
#include <unistd.h>

int main() {
    int sock;
    struct sockaddr_can addr;
    struct ifreq ifr;
    struct can_frame frame;

    // 소켓 생성
    sock = socket(PF_CAN, SOCK_RAW, CAN_RAW);

    // 사용할 CAN 인터페이스 지정 (예: can0)
    strcpy(ifr.ifr_name, "can0");
    ioctl(sock, SIOCGIFINDEX, &ifr);

    // 소켓 주소 설정
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    // 소켓을 CAN 인터페이스에 바인딩
    bind(sock, (struct sockaddr *)&addr, sizeof(addr));

    // CAN 프레임 설정 (ID, 데이터 길이, 데이터 값 등)
    frame.can_id = 0x123;
    frame.can_dlc = 2;
    frame.data[0] = 0xAB;
    frame.data[1] = 0xCD;

    // CAN 메시지 송신
    write(sock, &frame, sizeof(struct can_frame));

    // 소켓 닫기
    close(sock);
    return 0;
}
```

- CAN 소켓 수신 예시

```c
#include <linux/can.h>
#include <linux/can/raw.h>
#include <sys/socket.h>
#include <net/if.h>
#include <unistd.h>

int main() {
    int sock;
    struct sockaddr_can addr;
    struct ifreq ifr;
    struct can_frame frame;

    // 소켓 생성
    sock = socket(PF_CAN, SOCK_RAW, CAN_RAW);

    // 사용할 CAN 인터페이스 지정 (예: can0)
    strcpy(ifr.ifr_name, "can0");
    ioctl(sock, SIOCGIFINDEX, &ifr);

    // 소켓 주소 설정
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    // 소켓을 CAN 인터페이스에 바인딩
    bind(sock, (struct sockaddr *)&addr, sizeof(addr));

    // CAN 메시지 수신
    while (1) {
        int nbytes = read(sock, &frame, sizeof(struct can_frame));
        if (nbytes > 0) {
            printf("Received CAN ID: 0x%X, Data: 0x%X 0x%X\n", frame.can_id, frame.data[0], frame.data[1]);
        }
    }

    // 소켓 닫기
    close(sock);
    return 0;
}
```

- SocketCAN의 장점
    - 단순한 API: 기존의 소켓 API와 유사하게 작동하므로, 네트워크 프로그래밍 경험이 있으면 쉽게 접근할 수 있다.
    - 가상 인터페이스 지원: 실제 하드웨어 없이도 가상 CAN 인터페이스(예: vcan0)를 사용하여 테스트할 수 있다.
    - 고속 통신: CAN은 실시간 성능이 중요한 시스템에서 많이 사용되므로, SocketCAN도 이를 지원한다.
    - 필터링 및 확장성: 고급 필터링 기능을 통해 필요한 데이터만 선택적으로 처리할 수 있다.

### 자동차 네트워크 인터페이스의 중요성과 그 이유

- 안전성
    - 에어백, ABS, ESC 등 중요한 안전 시스템들이 서로 정보를 교환하여 사고를 예방하고, 차량의 안전성을 높인다.
- 효율성
    - 엔진 제어, 자동 변속 등 시스템들이 실시간으로 데이터를 주고받으며 차량의 연료 효율성과 주행 성능을 최적화한다.
- 통합 기능
    - 인포테인먼트 시스템, 운전 보조 시스템(ADAS), 자율주행 기술 등 다양한 기능들이 서로 연결되어 통합적인 차량 환경을 제공한다.
- 상태 모니터링 및 진단
    - 차량의 성능 및 상태를 모니터링하고 고장이 발생하면 실시간으로 진단 및 수리가 용이하다.
- 미래 기술
    - 자율주행 및 전기차 등의 미래 기술에서 V2V(Vehicle-to-Vehicle), V2I(Vehicle-to-Infrastructure) 통신을 통해 안전한 운행과 최적화된 교통 흐름을 지원한다.

### 자동차 네트워크 인터페이스가 차량 안전 및 기능에 미치는 영향

- 차량 안전성 강화:
    - 실시간 통신: 네트워크 인터페이스는 ABS, 에어백, ESC와 같은 안전 시스템들이 빠르게 데이터를 교환하고 실시간으로 반응하게 한다.
    - 사고 예방: 차량 내 시스템들이 서로 협력하여 운전자의 실수나 도로 상황에 맞춰 자동으로 개입하고 사고를 예방한다.
- 기능성 향상:
    - 운전 보조 시스템(ADAS): 차선 유지, 자동 비상 제동 등 운전 보조 시스템들이 차량의 센서와 통신하여 운전자의 편의성과 안전성을 높인다.
    - 자율 주행: 자율주행차에서는 차량 내 여러 센서와 ECU들이 V2V, V2I 통신을 통해 도로 상황을 파악하고 주행 전략을 수정한다.
- 성능 최적화:
    - 엔진 및 변속기 제어: 네트워크 인터페이스는 엔진과 변속기 등 시스템들이 실시간으로 데이터를 주고받아 연료 효율성과 주행 성능을 최적화한다.

### CAN 인터페이스가 느려도 지금까지 쓰이고 있는 이유

- 신뢰성: CAN은 실시간 통신을 지원하며 고장에 강해 차량 안전에 중요한 역할을 한다.
- 내구성: 고온, 진동, 잡음에도 안정적으로 작동해 자동차 산업에 적합하다.
- 구조 단순성: 저비용으로 구현 가능하고, 호환성 좋은 소프트웨어와 하드웨어가 제공된다.
- 확장성: 네트워크 확장이 용이해 여러 ECU를 연결해 통합적인 통신이 가능하다.
- 저전력: 전력 소비가 적어 배터리 구동 시스템에서 효율적이다.
- 효율성: 고속보다는 데이터 관리 효율성에 초점을 맞춘다.
- 산업 표준화: 많은 시스템에서 지원돼 기술 호환성이 보장된다.
- 대체 기술 차이: Ethernet, FlexRay보다 비용과 단순성에서 유리해 여전히 사용된다.